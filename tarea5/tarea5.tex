\documentclass{article}

\usepackage[utf8x]{inputenc}
\usepackage[spanish]{babel}
\usepackage[margin=3cm]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algorithmic}

\usepackage{ upgreek }

\usepackage{listings}

\linespread{1.2}

\title{ Computación Concurrente \\ \Large{Tarea 5}
\author{
  Diego Goméz Montesinos
  \and
  José Emiliano Cabrera Blancas
  }
\date{11 marzo 2014}
}
\begin{document}
\maketitle
\begin{enumerate}
  
\item{
    \textsl{
      Recuerden la platica de Borzoo sobre \textit{program
        repair}. Encuentra un algoritmo polinomial que repare la
      secuencia de estados, en el caso de una sola condición de
      progreso $\square$ (P $\Rightarrow$ $\triangle$Q), en donde hay
      un ciclo y sólo puedes quitar transiciones. Demuestra que es
      correcto y que es polinomial.
    }
  }

  \item{
      \textsl{
        Explicar por qué el proble de encontrar un ciclo que pase por
        2 vértices dados es NP-Completo. (Solo dar un esbozo de la
        prueba)
      }
    }

  \item{
      \textsl{
        Recordemos ahora el modelo de memoría compartida wait-free y
        asíncrono para n procesos. El algoritmo que ejecutan los
        procesos en primera instancia fue:
      }
      \begin{lstlisting}[frame=single,mathescape]
Alg (id):
        r := -1
        view := id
   loop:
        r  := r+1
        mem[r] := write(view)
        $\upchi$ := scan(mem[r])
        view := conjunto de id's en $\upchi$
   until | view | = n-r
   output view
      \end{lstlisting}
      \textsl{
        Después vimos una modificación al algoritmo, en el cual un
        proceso ''no olvida'' si en una iteración anterior vio a algún
        otro proceso. Cambiamos el código de la siguiente manera:
      }
\begin{lstlisting}[frame=single,mathescape]
AlgNoOlvida (id):
        r := -1
        view := id
   loop:
        r  := r+1
        mem[r] := write(view)
        $\upchi$ := scan(mem[r])
        view := view $\cup$ id's en $\upchi$
   until | view | >= n-r
   output view
      \end{lstlisting}
      \textsl{
        Demuestra que los dos algoritmos son correctos y que cumplen
        la propiedad de que las vistas de los procesos están
        contenidas de acuerdo al orden en que los procesos terminan su
        iteración. (i.e. el proceso j terminó después que el proceso
        k, entonces la vista del proceso j esta contenida en la vista
        del proceso k.)
      }
    }

  \item{
      \textsl{
        Hagan un resumen de la plática sobre consenso de no más de 2
        páginas de la platica de Michel Raynal.
      }

      \textbf{PROBLEMA DEL CONSENSO PARA SISTEMAS SÍNCRONOS}\\
      Primero vimos el modelo síncrono de secuencia de rondas.
      En este modelo tenemos lo siguiente:
      \begin{itemize}
        \item Un conjunto $\Uppi$ de n procesos $\{p_{1}, p_{2}, ..., p_{n}\}$
        \item Una red de comunicación confiable.
        \item Una ejecución consiste en una recuencia de rondas.
        \item Una variable global $r$ que será el número de ronda
        \item Cada proceso $p_{i}$ es informado cada vez que $r$ incrementa.
      \end{itemize}
      Cada ronda está hecha de tres fases consecutivas: Fase de envío, Fase de recibo y fase de procesamiento.
      En este modelo tenemos una propiedad fundamental (de sincronía) que es:\\
      " Un mensaje $m$ enviado por un proceso $p_{i}$ a un proceso $p_{j}$ en la ronda
      $r$, es recibido por $p_{j}$ en la misma ronda $r$".\\
      Ahora, que pasa si consideramos errorres o fallas en los procesos.\\
      En el modelo de fallos en los procesos podemos considerar estas cosas:
      \begin{itemize}
        \item Proceso defectuoso. Es aquel que se desvía de su algoritmo.
        \item Proceso correcto. Es aquel que nunca se desvía de su algoritmo.
        \item $f$, es el máximo número de procesos defectuosos.
        \item Tenemos que definir como un proceso puede desviarse de su especificación.
      \end{itemize}
       En este último tenemos estas opciones: Falla de ruptura: falla en el que $p_{i}$
       se detiene prematuramente; Falla por omisión: $p_{i}$ no envía o recibe 
       mensajes; Falla Bizantina: Se comporta arbitrariamente.\\
       Estos fallos tienen una jerarquía por su severidad:\\
       Falla de ruptura $<$ Falla por omisión $<$ Falla Bizantina.\\
       Ahora, enunciaremos el problema del consenso con algunas variantes:\\
       El problema del consenso es que todos los procesos deciden algún valor que
       tenga coherencia. Esto está dicho en términos de las siguientes propiedades:\\
       \begin{itemize}
        \item { T - Terminación. Todo proceso correcto eventualmente decide. }
        \item { V - Validez. Si un proceso decide $v$, entonces $v$ fué propuesto. }
        \item { A - Acuerdo. Dos procesos correctos nunca deciden diferente. }
        \item { UA - Acuerdo Uniforme. Dos procesos, correctos o no, nunca deciden
        diferente. }
        \item { WV - Validez Débil. Si todos los procesos correctos propusieron
        el mismo valor $v$, entonces $v$ es decidido. }
      \end{itemize}
      Con esto tenemos tres tipos de problemas de concenso: El clásico (T + A + V)
      que se puede resolver, con fallas de ruptura y de omisión; el uniforme (T + UA + 
      V) que se puede resolver igual que el anterior y el débil (T + A + WV) que solo
      puede resolverse con fallas Bizantina.\\
      Para resolver el caso de falla por ruptura ocupamos una estrategia de conjuntos
      inundados sobre una secuencia de rondas. En cada ronda $r$: se envúa la nueva
      información obtenida durante la ronda anterior $r - 1$. El número de rondas
      que correrá es de $f + 1$ (note que cualquier cadena de $f + 1$ procesos incluye
      un proceso correcto).\\
      El algoritmo es fácil, simplemente se va llenando un vector con lo que ya se vió
      y al final todos verán lo mismo y pueden decidir el primer valor distinto de nulo
      que todos ven.\\
      Analizando la correctez del algoritmo:
      \begin{itemize}
        \item { Terminación. Se sigue de la sincronía en la ronda $f + 1$. }
        \item { Validez. Se sigue de que $\forall(i, k): V_{i}[k]$ es $v_{k}$ ó
        $\bot$. }
        \item { Acuerdo Uniforme. Hay que demostrar que si $p_{i}$ y $p_{j}$ deciden
        valores tales que $V_{i} = V_{j}$ al final de la ronda $f + 1$.\\
        Sea  $V_{i}[k] = v_{k} \neq \bot$. Así que $p_{i}$ ve a $v_{k}$ en alguna
        ronda $r$. Entonces $r$ tiene dos opciones:
        \begin{itemize}
          \item {$r < f + 1$: entonces $p_{i}$ envió $(v_{k}, k)$ a $p_{j}$ en
          la ronda $r + 1 \leqslant f + 1$. }
          \item {$r = f + 1$: de $p_{k}$ a $p_{i}$, el par $(v_{k}, k)$ llego a travéz
          de la cadena de $f + 1$ procesos, y al menos uno de ellos es correcto,
          digamos $p_{x}$. Ahora, $p_{x}$ obtiene $(v_{k}, k)$ en la ronda $r' < f + 1$
          y es enviado a $p_{j}$ en la ronda $r' + 1 \leqslant f + 1$.}
        \end{itemize}
        }
      \end{itemize}
      Analizando el costo: tiempo: $f + 1$, sea $b = nb$ el número de bits para
      codificar un valor: un par $(v_{i}, i)$ requiere $b + log_{2}n$ bits, un
      proceso puede mandar a lo más una vez a otros procesos, la complejidad de
      la comunicación entonces es de:\\
      $n^{2}(n - 1)(b + log_{2}n)$


    }
    
\end{enumerate}
\end{document}